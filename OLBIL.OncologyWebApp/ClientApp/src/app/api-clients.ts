/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

@Injectable({
    providedIn: 'root'
})
export class AdministrativeDivisionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfAdministrativeDivisionModel | null> {
        let url_ = this.baseUrl + "/api/AdministrativeDivisions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAdministrativeDivisionModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAdministrativeDivisionModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfAdministrativeDivisionModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAdministrativeDivisionModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAdministrativeDivisionModel | null>(<any>null);
    }

    createAdministrativeDivision(model: AdministrativeDivisionModel): Observable<number> {
        let url_ = this.baseUrl + "/api/AdministrativeDivisions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdministrativeDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdministrativeDivision(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAdministrativeDivision(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateAdministrativeDivision(model: AdministrativeDivisionModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/AdministrativeDivisions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdministrativeDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdministrativeDivision(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdministrativeDivision(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfAdministrativeDivisionModel | null> {
        let url_ = this.baseUrl + "/api/AdministrativeDivisions/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAdministrativeDivisionModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAdministrativeDivisionModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfAdministrativeDivisionModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAdministrativeDivisionModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAdministrativeDivisionModel | null>(<any>null);
    }

    getAdministrativeDivision(id: number): Observable<AdministrativeDivisionModel | null> {
        let url_ = this.baseUrl + "/api/AdministrativeDivisions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdministrativeDivision(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdministrativeDivision(<any>response_);
                } catch (e) {
                    return <Observable<AdministrativeDivisionModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdministrativeDivisionModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdministrativeDivision(response: HttpResponseBase): Observable<AdministrativeDivisionModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AdministrativeDivisionModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdministrativeDivisionModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AmbulatoryAttentionRecordsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfAmbulatoryAttentionRecordModel | null> {
        let url_ = this.baseUrl + "/api/AmbulatoryAttentionRecords";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAmbulatoryAttentionRecordModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAmbulatoryAttentionRecordModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfAmbulatoryAttentionRecordModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAmbulatoryAttentionRecordModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAmbulatoryAttentionRecordModel | null>(<any>null);
    }

    createAmbulatoryAttentionRecord(model: AmbulatoryAttentionRecordModel): Observable<number> {
        let url_ = this.baseUrl + "/api/AmbulatoryAttentionRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAmbulatoryAttentionRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAmbulatoryAttentionRecord(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAmbulatoryAttentionRecord(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateAmbulatoryAttentionRecord(model: AmbulatoryAttentionRecordModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/AmbulatoryAttentionRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAmbulatoryAttentionRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAmbulatoryAttentionRecord(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAmbulatoryAttentionRecord(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfAmbulatoryAttentionRecordModel | null> {
        let url_ = this.baseUrl + "/api/AmbulatoryAttentionRecords/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAmbulatoryAttentionRecordModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAmbulatoryAttentionRecordModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfAmbulatoryAttentionRecordModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAmbulatoryAttentionRecordModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAmbulatoryAttentionRecordModel | null>(<any>null);
    }

    getAmbulatoryAttentionRecord(id: number): Observable<AmbulatoryAttentionRecordModel | null> {
        let url_ = this.baseUrl + "/api/AmbulatoryAttentionRecords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAmbulatoryAttentionRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAmbulatoryAttentionRecord(<any>response_);
                } catch (e) {
                    return <Observable<AmbulatoryAttentionRecordModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AmbulatoryAttentionRecordModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAmbulatoryAttentionRecord(response: HttpResponseBase): Observable<AmbulatoryAttentionRecordModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AmbulatoryAttentionRecordModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AmbulatoryAttentionRecordModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AppointmentReasonsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfAppointmentReasonModel | null> {
        let url_ = this.baseUrl + "/api/AppointmentReasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAppointmentReasonModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAppointmentReasonModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfAppointmentReasonModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAppointmentReasonModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAppointmentReasonModel | null>(<any>null);
    }

    createAppointmentReason(model: AppointmentReasonModel): Observable<number> {
        let url_ = this.baseUrl + "/api/AppointmentReasons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppointmentReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppointmentReason(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppointmentReason(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateAppointmentReason(model: AppointmentReasonModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/AppointmentReasons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppointmentReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointmentReason(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppointmentReason(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfAppointmentReasonModel | null> {
        let url_ = this.baseUrl + "/api/AppointmentReasons/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAppointmentReasonModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAppointmentReasonModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfAppointmentReasonModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAppointmentReasonModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAppointmentReasonModel | null>(<any>null);
    }

    getAppointmentReason(id: number): Observable<AppointmentReasonModel | null> {
        let url_ = this.baseUrl + "/api/AppointmentReasons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentReason(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentReason(<any>response_);
                } catch (e) {
                    return <Observable<AppointmentReasonModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppointmentReasonModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentReason(response: HttpResponseBase): Observable<AppointmentReasonModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppointmentReasonModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppointmentReasonModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AppointmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfAppointmentModel | null> {
        let url_ = this.baseUrl + "/api/Appointments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAppointmentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAppointmentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfAppointmentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAppointmentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAppointmentModel | null>(<any>null);
    }

    createAppointment(model: AppointmentModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppointment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateAppointment(model: AppointmentModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppointment(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfAppointmentModel | null> {
        let url_ = this.baseUrl + "/api/Appointments/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfAppointmentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfAppointmentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfAppointmentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfAppointmentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfAppointmentModel | null>(<any>null);
    }

    getAppointment(id: number): Observable<AppointmentModel | null> {
        let url_ = this.baseUrl + "/api/Appointments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointment(<any>response_);
                } catch (e) {
                    return <Observable<AppointmentModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppointmentModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointment(response: HttpResponseBase): Observable<AppointmentModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppointmentModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppointmentModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BedsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfBedModel | null> {
        let url_ = this.baseUrl + "/api/Beds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfBedModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfBedModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfBedModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfBedModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfBedModel | null>(<any>null);
    }

    createBed(model: BedModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Beds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBed(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBed(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateBed(model: BedModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Beds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBed(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBed(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfBedModel | null> {
        let url_ = this.baseUrl + "/api/Beds/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfBedModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfBedModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfBedModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfBedModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfBedModel | null>(<any>null);
    }

    getBed(id: number): Observable<BedModel | null> {
        let url_ = this.baseUrl + "/api/Beds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBed(<any>response_);
                } catch (e) {
                    return <Observable<BedModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BedModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBed(response: HttpResponseBase): Observable<BedModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BedModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BedModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BuildingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfBuildingModel | null> {
        let url_ = this.baseUrl + "/api/Buildings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfBuildingModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfBuildingModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfBuildingModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfBuildingModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfBuildingModel | null>(<any>null);
    }

    createBuilding(model: BuildingModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Buildings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBuilding(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBuilding(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateBuilding(model: BuildingModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Buildings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBuilding(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBuilding(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfBuildingModel | null> {
        let url_ = this.baseUrl + "/api/Buildings/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfBuildingModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfBuildingModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfBuildingModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfBuildingModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfBuildingModel | null>(<any>null);
    }

    getBuilding(id: number): Observable<BuildingModel | null> {
        let url_ = this.baseUrl + "/api/Buildings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuilding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuilding(<any>response_);
                } catch (e) {
                    return <Observable<BuildingModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetBuilding(response: HttpResponseBase): Observable<BuildingModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BuildingModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfCountryModel | null> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfCountryModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfCountryModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfCountryModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfCountryModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfCountryModel | null>(<any>null);
    }

    createCountry(model: CountryModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCountry(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCountry(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateCountry(model: CountryModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Countries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCountry(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCountry(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfCountryModel | null> {
        let url_ = this.baseUrl + "/api/Countries/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfCountryModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfCountryModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfCountryModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfCountryModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfCountryModel | null>(<any>null);
    }

    getCountry(id: number): Observable<CountryModel | null> {
        let url_ = this.baseUrl + "/api/Countries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(<any>response_);
                } catch (e) {
                    return <Observable<CountryModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<CountryModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CountryModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DiagnosesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfDiagnosisModel | null> {
        let url_ = this.baseUrl + "/api/Diagnoses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfDiagnosisModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfDiagnosisModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfDiagnosisModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfDiagnosisModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfDiagnosisModel | null>(<any>null);
    }

    createDiagnosis(model: DiagnosisModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Diagnoses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDiagnosis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDiagnosis(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDiagnosis(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateDiagnosis(model: DiagnosisModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Diagnoses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDiagnosis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDiagnosis(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDiagnosis(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfDiagnosisModel | null> {
        let url_ = this.baseUrl + "/api/Diagnoses/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfDiagnosisModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfDiagnosisModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfDiagnosisModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfDiagnosisModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfDiagnosisModel | null>(<any>null);
    }

    getDiagnosis(id: number): Observable<DiagnosisModel | null> {
        let url_ = this.baseUrl + "/api/Diagnoses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiagnosis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiagnosis(<any>response_);
                } catch (e) {
                    return <Observable<DiagnosisModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiagnosisModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetDiagnosis(response: HttpResponseBase): Observable<DiagnosisModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DiagnosisModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiagnosisModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class EvolutionCardsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfEvolutionCardModel | null> {
        let url_ = this.baseUrl + "/api/EvolutionCards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfEvolutionCardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfEvolutionCardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfEvolutionCardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfEvolutionCardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfEvolutionCardModel | null>(<any>null);
    }

    createEvolutionCard(model: EvolutionCardModel): Observable<number> {
        let url_ = this.baseUrl + "/api/EvolutionCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvolutionCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvolutionCard(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEvolutionCard(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateEvolutionCard(model: EvolutionCardModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/EvolutionCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEvolutionCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEvolutionCard(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEvolutionCard(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfEvolutionCardModel | null> {
        let url_ = this.baseUrl + "/api/EvolutionCards/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfEvolutionCardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfEvolutionCardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfEvolutionCardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfEvolutionCardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfEvolutionCardModel | null>(<any>null);
    }

    getEvolutionCard(id: number): Observable<EvolutionCardModel | null> {
        let url_ = this.baseUrl + "/api/EvolutionCards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvolutionCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvolutionCard(<any>response_);
                } catch (e) {
                    return <Observable<EvolutionCardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<EvolutionCardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetEvolutionCard(response: HttpResponseBase): Observable<EvolutionCardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EvolutionCardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EvolutionCardModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HealthProfessionalsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfHealthProfessionalModel | null> {
        let url_ = this.baseUrl + "/api/HealthProfessionals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfHealthProfessionalModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfHealthProfessionalModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfHealthProfessionalModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfHealthProfessionalModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfHealthProfessionalModel | null>(<any>null);
    }

    createHealthProfessional(model: HealthProfessionalModel): Observable<number> {
        let url_ = this.baseUrl + "/api/HealthProfessionals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHealthProfessional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHealthProfessional(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHealthProfessional(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateHealthProfessional(model: HealthProfessionalModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/HealthProfessionals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHealthProfessional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHealthProfessional(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHealthProfessional(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfHealthProfessionalModel | null> {
        let url_ = this.baseUrl + "/api/HealthProfessionals/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfHealthProfessionalModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfHealthProfessionalModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfHealthProfessionalModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfHealthProfessionalModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfHealthProfessionalModel | null>(<any>null);
    }

    getHealthProfessional(id: number): Observable<HealthProfessionalModel | null> {
        let url_ = this.baseUrl + "/api/HealthProfessionals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHealthProfessional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHealthProfessional(<any>response_);
                } catch (e) {
                    return <Observable<HealthProfessionalModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<HealthProfessionalModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetHealthProfessional(response: HttpResponseBase): Observable<HealthProfessionalModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HealthProfessionalModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HealthProfessionalModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HospitalUnitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfHospitalUnitModel | null> {
        let url_ = this.baseUrl + "/api/HospitalUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfHospitalUnitModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfHospitalUnitModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfHospitalUnitModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfHospitalUnitModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfHospitalUnitModel | null>(<any>null);
    }

    createHospitalUnit(model: HospitalUnitModel): Observable<number> {
        let url_ = this.baseUrl + "/api/HospitalUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHospitalUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHospitalUnit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHospitalUnit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateHospitalUnit(model: HospitalUnitModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/HospitalUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHospitalUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHospitalUnit(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHospitalUnit(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfHospitalUnitModel | null> {
        let url_ = this.baseUrl + "/api/HospitalUnits/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfHospitalUnitModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfHospitalUnitModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfHospitalUnitModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfHospitalUnitModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfHospitalUnitModel | null>(<any>null);
    }

    getHospitalUnit(id: number): Observable<HospitalUnitModel | null> {
        let url_ = this.baseUrl + "/api/HospitalUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHospitalUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHospitalUnit(<any>response_);
                } catch (e) {
                    return <Observable<HospitalUnitModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalUnitModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetHospitalUnit(response: HttpResponseBase): Observable<HospitalUnitModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HospitalUnitModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalUnitModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MedicalSpecialtiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfMedicalSpecialtyModel | null> {
        let url_ = this.baseUrl + "/api/MedicalSpecialties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfMedicalSpecialtyModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfMedicalSpecialtyModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfMedicalSpecialtyModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfMedicalSpecialtyModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfMedicalSpecialtyModel | null>(<any>null);
    }

    createMedicalSpecialty(model: MedicalSpecialtyModel): Observable<number> {
        let url_ = this.baseUrl + "/api/MedicalSpecialties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedicalSpecialty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedicalSpecialty(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMedicalSpecialty(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateMedicalSpecialty(model: MedicalSpecialtyModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/MedicalSpecialties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMedicalSpecialty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMedicalSpecialty(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMedicalSpecialty(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfMedicalSpecialtyModel | null> {
        let url_ = this.baseUrl + "/api/MedicalSpecialties/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfMedicalSpecialtyModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfMedicalSpecialtyModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfMedicalSpecialtyModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfMedicalSpecialtyModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfMedicalSpecialtyModel | null>(<any>null);
    }

    getMedicalSpecialty(id: number): Observable<MedicalSpecialtyModel | null> {
        let url_ = this.baseUrl + "/api/MedicalSpecialties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalSpecialty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalSpecialty(<any>response_);
                } catch (e) {
                    return <Observable<MedicalSpecialtyModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalSpecialtyModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalSpecialty(response: HttpResponseBase): Observable<MedicalSpecialtyModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalSpecialtyModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalSpecialtyModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OncologyPatientsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfOncologyPatientModel | null> {
        let url_ = this.baseUrl + "/api/OncologyPatients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfOncologyPatientModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfOncologyPatientModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfOncologyPatientModel | null>(<any>null);
    }

    createPatient(model: OncologyPatientModel): Observable<number> {
        let url_ = this.baseUrl + "/api/OncologyPatients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePatient(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePatient(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updatePatient(model: OncologyPatientModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/OncologyPatients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePatient(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePatient(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfOncologyPatientModel | null> {
        let url_ = this.baseUrl + "/api/OncologyPatients/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfOncologyPatientModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfOncologyPatientModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfOncologyPatientModel | null>(<any>null);
    }

    getPatient(id: number): Observable<OncologyPatientModel | null> {
        let url_ = this.baseUrl + "/api/OncologyPatients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPatient(<any>response_);
                } catch (e) {
                    return <Observable<OncologyPatientModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<OncologyPatientModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetPatient(response: HttpResponseBase): Observable<OncologyPatientModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OncologyPatientModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OncologyPatientModel | null>(<any>null);
    }

    attemptCreatePatient(model: OncologyPatientModel): Observable<ListModelOfOncologyPatientModel | null> {
        let url_ = this.baseUrl + "/api/OncologyPatients/attempt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttemptCreatePatient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttemptCreatePatient(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfOncologyPatientModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processAttemptCreatePatient(response: HttpResponseBase): Observable<ListModelOfOncologyPatientModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfOncologyPatientModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfOncologyPatientModel | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WardsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject('BASE_URL') baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:44330";
    }

    getAll(): Observable<ListModelOfWardModel | null> {
        let url_ = this.baseUrl + "/api/Wards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfWardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfWardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListModelOfWardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfWardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfWardModel | null>(<any>null);
    }

    createWard(model: WardModel): Observable<number> {
        let url_ = this.baseUrl + "/api/Wards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWard(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWard(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateWard(model: WardModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Wards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWard(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWard(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    search(searchTerm: string | null | undefined): Observable<ListModelOfWardModel | null> {
        let url_ = this.baseUrl + "/api/Wards/search?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListModelOfWardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListModelOfWardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListModelOfWardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListModelOfWardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListModelOfWardModel | null>(<any>null);
    }

    getWard(id: number): Observable<WardModel | null> {
        let url_ = this.baseUrl + "/api/Wards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWard(<any>response_);
                } catch (e) {
                    return <Observable<WardModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<WardModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetWard(response: HttpResponseBase): Observable<WardModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WardModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardModel | null>(<any>null);
    }
}

export class ListModelOfAdministrativeDivisionModel implements IListModelOfAdministrativeDivisionModel {
    items?: AdministrativeDivisionModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfAdministrativeDivisionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AdministrativeDivisionModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfAdministrativeDivisionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfAdministrativeDivisionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfAdministrativeDivisionModel {
    items?: AdministrativeDivisionModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class AdministrativeDivisionModel implements IAdministrativeDivisionModel {
    administrativeDivisionId!: number;
    code?: string | undefined;
    name?: string | undefined;
    level!: number;
    parentId?: number | undefined;

    constructor(data?: IAdministrativeDivisionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.administrativeDivisionId = data["administrativeDivisionId"];
            this.code = data["code"];
            this.name = data["name"];
            this.level = data["level"];
            this.parentId = data["parentId"];
        }
    }

    static fromJS(data: any): AdministrativeDivisionModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdministrativeDivisionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["administrativeDivisionId"] = this.administrativeDivisionId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["parentId"] = this.parentId;
        return data; 
    }
}

export interface IAdministrativeDivisionModel {
    administrativeDivisionId: number;
    code?: string | undefined;
    name?: string | undefined;
    level: number;
    parentId?: number | undefined;
}

export class ListModelOfAmbulatoryAttentionRecordModel implements IListModelOfAmbulatoryAttentionRecordModel {
    items?: AmbulatoryAttentionRecordModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfAmbulatoryAttentionRecordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AmbulatoryAttentionRecordModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfAmbulatoryAttentionRecordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfAmbulatoryAttentionRecordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfAmbulatoryAttentionRecordModel {
    items?: AmbulatoryAttentionRecordModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class AmbulatoryAttentionRecordModel implements IAmbulatoryAttentionRecordModel {
    ambulatoryAttentionRecordId?: number | undefined;
    healthProfessionalId?: number | undefined;
    oncologyPatientId?: number | undefined;
    isNewPatient!: boolean;
    diagnosisId?: number | undefined;
    treatmentPhase?: string | undefined;
    diseaseEventDescription?: string | undefined;
    nextAppointmentDate?: Date | undefined;
    date?: Date | undefined;
    referredTo?: string | undefined;
    receivedFrom?: string | undefined;

    constructor(data?: IAmbulatoryAttentionRecordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ambulatoryAttentionRecordId = data["ambulatoryAttentionRecordId"];
            this.healthProfessionalId = data["healthProfessionalId"];
            this.oncologyPatientId = data["oncologyPatientId"];
            this.isNewPatient = data["isNewPatient"];
            this.diagnosisId = data["diagnosisId"];
            this.treatmentPhase = data["treatmentPhase"];
            this.diseaseEventDescription = data["diseaseEventDescription"];
            this.nextAppointmentDate = data["nextAppointmentDate"] ? new Date(data["nextAppointmentDate"].toString()) : <any>undefined;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.referredTo = data["referredTo"];
            this.receivedFrom = data["receivedFrom"];
        }
    }

    static fromJS(data: any): AmbulatoryAttentionRecordModel {
        data = typeof data === 'object' ? data : {};
        let result = new AmbulatoryAttentionRecordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ambulatoryAttentionRecordId"] = this.ambulatoryAttentionRecordId;
        data["healthProfessionalId"] = this.healthProfessionalId;
        data["oncologyPatientId"] = this.oncologyPatientId;
        data["isNewPatient"] = this.isNewPatient;
        data["diagnosisId"] = this.diagnosisId;
        data["treatmentPhase"] = this.treatmentPhase;
        data["diseaseEventDescription"] = this.diseaseEventDescription;
        data["nextAppointmentDate"] = this.nextAppointmentDate ? this.nextAppointmentDate.toISOString() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["referredTo"] = this.referredTo;
        data["receivedFrom"] = this.receivedFrom;
        return data; 
    }
}

export interface IAmbulatoryAttentionRecordModel {
    ambulatoryAttentionRecordId?: number | undefined;
    healthProfessionalId?: number | undefined;
    oncologyPatientId?: number | undefined;
    isNewPatient: boolean;
    diagnosisId?: number | undefined;
    treatmentPhase?: string | undefined;
    diseaseEventDescription?: string | undefined;
    nextAppointmentDate?: Date | undefined;
    date?: Date | undefined;
    referredTo?: string | undefined;
    receivedFrom?: string | undefined;
}

export class ListModelOfAppointmentReasonModel implements IListModelOfAppointmentReasonModel {
    items?: AppointmentReasonModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfAppointmentReasonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AppointmentReasonModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfAppointmentReasonModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfAppointmentReasonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfAppointmentReasonModel {
    items?: AppointmentReasonModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class AppointmentReasonModel implements IAppointmentReasonModel {
    appointmentReasonId!: number;
    description?: string | undefined;

    constructor(data?: IAppointmentReasonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appointmentReasonId = data["appointmentReasonId"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): AppointmentReasonModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentReasonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentReasonId"] = this.appointmentReasonId;
        data["description"] = this.description;
        return data; 
    }
}

export interface IAppointmentReasonModel {
    appointmentReasonId: number;
    description?: string | undefined;
}

export class ListModelOfAppointmentModel implements IListModelOfAppointmentModel {
    items?: AppointmentModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfAppointmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AppointmentModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfAppointmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfAppointmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfAppointmentModel {
    items?: AppointmentModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class AppointmentModel implements IAppointmentModel {
    appointmentId?: number | undefined;
    oncologyPatientId?: number | undefined;
    healthProfessionalId?: number | undefined;
    appointmentStatusId?: AppointmentStatus | undefined;
    appointmentStatusName?: string | undefined;
    date?: Date | undefined;
    attentionBlocks?: string | undefined;
    patientAttended!: boolean;
    rescheduledAppointmentId?: number | undefined;
    appointmentReasonId?: number | undefined;
    notes?: string | undefined;
    specialNotes?: string | undefined;

    constructor(data?: IAppointmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appointmentId = data["appointmentId"];
            this.oncologyPatientId = data["oncologyPatientId"];
            this.healthProfessionalId = data["healthProfessionalId"];
            this.appointmentStatusId = data["appointmentStatusId"];
            this.appointmentStatusName = data["appointmentStatusName"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.attentionBlocks = data["attentionBlocks"];
            this.patientAttended = data["patientAttended"];
            this.rescheduledAppointmentId = data["rescheduledAppointmentId"];
            this.appointmentReasonId = data["appointmentReasonId"];
            this.notes = data["notes"];
            this.specialNotes = data["specialNotes"];
        }
    }

    static fromJS(data: any): AppointmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appointmentId"] = this.appointmentId;
        data["oncologyPatientId"] = this.oncologyPatientId;
        data["healthProfessionalId"] = this.healthProfessionalId;
        data["appointmentStatusId"] = this.appointmentStatusId;
        data["appointmentStatusName"] = this.appointmentStatusName;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["attentionBlocks"] = this.attentionBlocks;
        data["patientAttended"] = this.patientAttended;
        data["rescheduledAppointmentId"] = this.rescheduledAppointmentId;
        data["appointmentReasonId"] = this.appointmentReasonId;
        data["notes"] = this.notes;
        data["specialNotes"] = this.specialNotes;
        return data; 
    }
}

export interface IAppointmentModel {
    appointmentId?: number | undefined;
    oncologyPatientId?: number | undefined;
    healthProfessionalId?: number | undefined;
    appointmentStatusId?: AppointmentStatus | undefined;
    appointmentStatusName?: string | undefined;
    date?: Date | undefined;
    attentionBlocks?: string | undefined;
    patientAttended: boolean;
    rescheduledAppointmentId?: number | undefined;
    appointmentReasonId?: number | undefined;
    notes?: string | undefined;
    specialNotes?: string | undefined;
}

export enum AppointmentStatus {
    Scheduled = 0, 
    InProgress = 1, 
    Completed = 2, 
    Cancelled = 3, 
}

export class ListModelOfBedModel implements IListModelOfBedModel {
    items?: BedModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfBedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BedModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfBedModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfBedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfBedModel {
    items?: BedModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class BedModel implements IBedModel {
    bedId?: number | undefined;
    name?: string | undefined;
    longDescription?: string | undefined;
    wardId?: number | undefined;
    bedStatusId?: BedStatus | undefined;
    bedStatusName?: string | undefined;

    constructor(data?: IBedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bedId = data["bedId"];
            this.name = data["name"];
            this.longDescription = data["longDescription"];
            this.wardId = data["wardId"];
            this.bedStatusId = data["bedStatusId"];
            this.bedStatusName = data["bedStatusName"];
        }
    }

    static fromJS(data: any): BedModel {
        data = typeof data === 'object' ? data : {};
        let result = new BedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bedId"] = this.bedId;
        data["name"] = this.name;
        data["longDescription"] = this.longDescription;
        data["wardId"] = this.wardId;
        data["bedStatusId"] = this.bedStatusId;
        data["bedStatusName"] = this.bedStatusName;
        return data; 
    }
}

export interface IBedModel {
    bedId?: number | undefined;
    name?: string | undefined;
    longDescription?: string | undefined;
    wardId?: number | undefined;
    bedStatusId?: BedStatus | undefined;
    bedStatusName?: string | undefined;
}

export enum BedStatus {
    Free = 0, 
    Occupied = 1, 
    NotAvailable = 2, 
}

export class ListModelOfBuildingModel implements IListModelOfBuildingModel {
    items?: BuildingModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfBuildingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BuildingModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfBuildingModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfBuildingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfBuildingModel {
    items?: BuildingModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class BuildingModel implements IBuildingModel {
    buildingId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IBuildingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildingId = data["buildingId"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BuildingModel {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildingId"] = this.buildingId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBuildingModel {
    buildingId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class ListModelOfCountryModel implements IListModelOfCountryModel {
    items?: CountryModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfCountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CountryModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfCountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfCountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfCountryModel {
    items?: CountryModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class CountryModel implements ICountryModel {
    countryId?: number | undefined;
    isoCode3?: string | undefined;
    isoCode2?: string | undefined;
    nameEn?: string | undefined;
    nameEs?: string | undefined;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryId = data["countryId"];
            this.isoCode3 = data["isoCode3"];
            this.isoCode2 = data["isoCode2"];
            this.nameEn = data["nameEn"];
            this.nameEs = data["nameEs"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["isoCode3"] = this.isoCode3;
        data["isoCode2"] = this.isoCode2;
        data["nameEn"] = this.nameEn;
        data["nameEs"] = this.nameEs;
        return data; 
    }
}

export interface ICountryModel {
    countryId?: number | undefined;
    isoCode3?: string | undefined;
    isoCode2?: string | undefined;
    nameEn?: string | undefined;
    nameEs?: string | undefined;
}

export class ListModelOfDiagnosisModel implements IListModelOfDiagnosisModel {
    items?: DiagnosisModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfDiagnosisModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DiagnosisModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfDiagnosisModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfDiagnosisModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfDiagnosisModel {
    items?: DiagnosisModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class DiagnosisModel implements IDiagnosisModel {
    diagnosisId?: number | undefined;
    icdCode?: string | undefined;
    completeDescriptor?: string | undefined;
    shortDescriptor?: string | undefined;

    constructor(data?: IDiagnosisModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diagnosisId = data["diagnosisId"];
            this.icdCode = data["icdCode"];
            this.completeDescriptor = data["completeDescriptor"];
            this.shortDescriptor = data["shortDescriptor"];
        }
    }

    static fromJS(data: any): DiagnosisModel {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosisModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diagnosisId"] = this.diagnosisId;
        data["icdCode"] = this.icdCode;
        data["completeDescriptor"] = this.completeDescriptor;
        data["shortDescriptor"] = this.shortDescriptor;
        return data; 
    }
}

export interface IDiagnosisModel {
    diagnosisId?: number | undefined;
    icdCode?: string | undefined;
    completeDescriptor?: string | undefined;
    shortDescriptor?: string | undefined;
}

export class ListModelOfEvolutionCardModel implements IListModelOfEvolutionCardModel {
    items?: EvolutionCardModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfEvolutionCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EvolutionCardModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfEvolutionCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfEvolutionCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfEvolutionCardModel {
    items?: EvolutionCardModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class EvolutionCardModel implements IEvolutionCardModel {
    evolutionCardId?: number | undefined;
    oncologyPatientId?: number | undefined;
    appointmentId?: number | undefined;
    heightCm?: number | undefined;
    weightKg?: number | undefined;
    temperatureC?: number | undefined;
    heartBeatRateBpm?: number | undefined;
    diagnosisId?: number | undefined;
    directions?: string | undefined;
    observations?: string | undefined;
    nextAppointmentDate?: Date | undefined;
    referredTo?: string | undefined;
    healthProfessionalId?: number | undefined;
    bodyMassIndex?: number | undefined;

    constructor(data?: IEvolutionCardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.evolutionCardId = data["evolutionCardId"];
            this.oncologyPatientId = data["oncologyPatientId"];
            this.appointmentId = data["appointmentId"];
            this.heightCm = data["heightCm"];
            this.weightKg = data["weightKg"];
            this.temperatureC = data["temperatureC"];
            this.heartBeatRateBpm = data["heartBeatRateBpm"];
            this.diagnosisId = data["diagnosisId"];
            this.directions = data["directions"];
            this.observations = data["observations"];
            this.nextAppointmentDate = data["nextAppointmentDate"] ? new Date(data["nextAppointmentDate"].toString()) : <any>undefined;
            this.referredTo = data["referredTo"];
            this.healthProfessionalId = data["healthProfessionalId"];
            this.bodyMassIndex = data["bodyMassIndex"];
        }
    }

    static fromJS(data: any): EvolutionCardModel {
        data = typeof data === 'object' ? data : {};
        let result = new EvolutionCardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evolutionCardId"] = this.evolutionCardId;
        data["oncologyPatientId"] = this.oncologyPatientId;
        data["appointmentId"] = this.appointmentId;
        data["heightCm"] = this.heightCm;
        data["weightKg"] = this.weightKg;
        data["temperatureC"] = this.temperatureC;
        data["heartBeatRateBpm"] = this.heartBeatRateBpm;
        data["diagnosisId"] = this.diagnosisId;
        data["directions"] = this.directions;
        data["observations"] = this.observations;
        data["nextAppointmentDate"] = this.nextAppointmentDate ? this.nextAppointmentDate.toISOString() : <any>undefined;
        data["referredTo"] = this.referredTo;
        data["healthProfessionalId"] = this.healthProfessionalId;
        data["bodyMassIndex"] = this.bodyMassIndex;
        return data; 
    }
}

export interface IEvolutionCardModel {
    evolutionCardId?: number | undefined;
    oncologyPatientId?: number | undefined;
    appointmentId?: number | undefined;
    heightCm?: number | undefined;
    weightKg?: number | undefined;
    temperatureC?: number | undefined;
    heartBeatRateBpm?: number | undefined;
    diagnosisId?: number | undefined;
    directions?: string | undefined;
    observations?: string | undefined;
    nextAppointmentDate?: Date | undefined;
    referredTo?: string | undefined;
    healthProfessionalId?: number | undefined;
    bodyMassIndex?: number | undefined;
}

export class ListModelOfHealthProfessionalModel implements IListModelOfHealthProfessionalModel {
    items?: HealthProfessionalModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfHealthProfessionalModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(HealthProfessionalModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfHealthProfessionalModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfHealthProfessionalModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfHealthProfessionalModel {
    items?: HealthProfessionalModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class HealthProfessionalModel implements IHealthProfessionalModel {
    healthProfessionalId?: number | undefined;
    personId?: string | undefined;
    person?: PersonModel | undefined;
    mainSpecialtyId?: number | undefined;

    constructor(data?: IHealthProfessionalModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.healthProfessionalId = data["healthProfessionalId"];
            this.personId = data["personId"];
            this.person = data["person"] ? PersonModel.fromJS(data["person"]) : <any>undefined;
            this.mainSpecialtyId = data["mainSpecialtyId"];
        }
    }

    static fromJS(data: any): HealthProfessionalModel {
        data = typeof data === 'object' ? data : {};
        let result = new HealthProfessionalModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthProfessionalId"] = this.healthProfessionalId;
        data["personId"] = this.personId;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["mainSpecialtyId"] = this.mainSpecialtyId;
        return data; 
    }
}

export interface IHealthProfessionalModel {
    healthProfessionalId?: number | undefined;
    personId?: string | undefined;
    person?: PersonModel | undefined;
    mainSpecialtyId?: number | undefined;
}

export class PersonModel implements IPersonModel {
    personId?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    additionalLastName?: string | undefined;
    preferredName?: string | undefined;
    governmentIDNumber?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    homePhone?: string | undefined;
    mobilePhone?: string | undefined;
    nationality?: string | undefined;
    race?: string | undefined;
    gender?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    familyStatus?: string | undefined;
    schoolLevel?: string | undefined;
    methodOfTranspotation?: string | undefined;

    constructor(data?: IPersonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.personId = data["personId"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.additionalLastName = data["additionalLastName"];
            this.preferredName = data["preferredName"];
            this.governmentIDNumber = data["governmentIDNumber"];
            this.address = data["address"];
            this.addressLine2 = data["addressLine2"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.homePhone = data["homePhone"];
            this.mobilePhone = data["mobilePhone"];
            this.nationality = data["nationality"];
            this.race = data["race"];
            this.gender = data["gender"];
            this.birthdate = data["birthdate"] ? new Date(data["birthdate"].toString()) : <any>undefined;
            this.birthplace = data["birthplace"];
            this.familyStatus = data["familyStatus"];
            this.schoolLevel = data["schoolLevel"];
            this.methodOfTranspotation = data["methodOfTranspotation"];
        }
    }

    static fromJS(data: any): PersonModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["additionalLastName"] = this.additionalLastName;
        data["preferredName"] = this.preferredName;
        data["governmentIDNumber"] = this.governmentIDNumber;
        data["address"] = this.address;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["homePhone"] = this.homePhone;
        data["mobilePhone"] = this.mobilePhone;
        data["nationality"] = this.nationality;
        data["race"] = this.race;
        data["gender"] = this.gender;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["birthplace"] = this.birthplace;
        data["familyStatus"] = this.familyStatus;
        data["schoolLevel"] = this.schoolLevel;
        data["methodOfTranspotation"] = this.methodOfTranspotation;
        return data; 
    }
}

export interface IPersonModel {
    personId?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    additionalLastName?: string | undefined;
    preferredName?: string | undefined;
    governmentIDNumber?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    homePhone?: string | undefined;
    mobilePhone?: string | undefined;
    nationality?: string | undefined;
    race?: string | undefined;
    gender?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    familyStatus?: string | undefined;
    schoolLevel?: string | undefined;
    methodOfTranspotation?: string | undefined;
}

export class ListModelOfHospitalUnitModel implements IListModelOfHospitalUnitModel {
    items?: HospitalUnitModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfHospitalUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(HospitalUnitModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfHospitalUnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfHospitalUnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfHospitalUnitModel {
    items?: HospitalUnitModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class HospitalUnitModel implements IHospitalUnitModel {
    hospitalUnitId!: number;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IHospitalUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.hospitalUnitId = data["hospitalUnitId"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): HospitalUnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalUnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hospitalUnitId"] = this.hospitalUnitId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IHospitalUnitModel {
    hospitalUnitId: number;
    code?: string | undefined;
    name?: string | undefined;
}

export class ListModelOfMedicalSpecialtyModel implements IListModelOfMedicalSpecialtyModel {
    items?: MedicalSpecialtyModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfMedicalSpecialtyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MedicalSpecialtyModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfMedicalSpecialtyModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfMedicalSpecialtyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfMedicalSpecialtyModel {
    items?: MedicalSpecialtyModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class MedicalSpecialtyModel implements IMedicalSpecialtyModel {
    medicalSpecialtyId?: number | undefined;
    description?: string | undefined;

    constructor(data?: IMedicalSpecialtyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.medicalSpecialtyId = data["medicalSpecialtyId"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): MedicalSpecialtyModel {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalSpecialtyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["medicalSpecialtyId"] = this.medicalSpecialtyId;
        data["description"] = this.description;
        return data; 
    }
}

export interface IMedicalSpecialtyModel {
    medicalSpecialtyId?: number | undefined;
    description?: string | undefined;
}

export class ListModelOfOncologyPatientModel implements IListModelOfOncologyPatientModel {
    items?: OncologyPatientModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfOncologyPatientModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OncologyPatientModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfOncologyPatientModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfOncologyPatientModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfOncologyPatientModel {
    items?: OncologyPatientModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class OncologyPatientModel implements IOncologyPatientModel {
    oncologyPatientId?: number | undefined;
    person?: PersonModel | undefined;
    registrationDate?: Date | undefined;
    admissionDate?: Date | undefined;
    informantsRelationship?: string | undefined;
    reasonForReferral?: string | undefined;

    constructor(data?: IOncologyPatientModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oncologyPatientId = data["oncologyPatientId"];
            this.person = data["person"] ? PersonModel.fromJS(data["person"]) : <any>undefined;
            this.registrationDate = data["registrationDate"] ? new Date(data["registrationDate"].toString()) : <any>undefined;
            this.admissionDate = data["admissionDate"] ? new Date(data["admissionDate"].toString()) : <any>undefined;
            this.informantsRelationship = data["informantsRelationship"];
            this.reasonForReferral = data["reasonForReferral"];
        }
    }

    static fromJS(data: any): OncologyPatientModel {
        data = typeof data === 'object' ? data : {};
        let result = new OncologyPatientModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oncologyPatientId"] = this.oncologyPatientId;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["admissionDate"] = this.admissionDate ? this.admissionDate.toISOString() : <any>undefined;
        data["informantsRelationship"] = this.informantsRelationship;
        data["reasonForReferral"] = this.reasonForReferral;
        return data; 
    }
}

export interface IOncologyPatientModel {
    oncologyPatientId?: number | undefined;
    person?: PersonModel | undefined;
    registrationDate?: Date | undefined;
    admissionDate?: Date | undefined;
    informantsRelationship?: string | undefined;
    reasonForReferral?: string | undefined;
}

export class ListModelOfWardModel implements IListModelOfWardModel {
    items?: WardModel[] | undefined;
    itemCount!: number;
    pageIndex!: number;
    totalCount!: number;
    totalPages!: number;
    pageSize!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    constructor(data?: IListModelOfWardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WardModel.fromJS(item));
            }
            this.itemCount = data["itemCount"];
            this.pageIndex = data["pageIndex"];
            this.totalCount = data["totalCount"];
            this.totalPages = data["totalPages"];
            this.pageSize = data["pageSize"];
            this.hasPreviousPage = data["hasPreviousPage"];
            this.hasNextPage = data["hasNextPage"];
        }
    }

    static fromJS(data: any): ListModelOfWardModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListModelOfWardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["itemCount"] = this.itemCount;
        data["pageIndex"] = this.pageIndex;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IListModelOfWardModel {
    items?: WardModel[] | undefined;
    itemCount: number;
    pageIndex: number;
    totalCount: number;
    totalPages: number;
    pageSize: number;
    hasPreviousPage: boolean;
    hasNextPage: boolean;
}

export class WardModel implements IWardModel {
    wardId?: number | undefined;
    name?: string | undefined;
    buildingId?: number | undefined;
    floorNumber?: number | undefined;
    hospitalUnitId?: number | undefined;
    wardGenderName?: string | undefined;
    wardStatusName?: string | undefined;
    wardGenderId?: WardGender | undefined;
    wardStatusId?: WardStatus | undefined;

    constructor(data?: IWardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wardId = data["wardId"];
            this.name = data["name"];
            this.buildingId = data["buildingId"];
            this.floorNumber = data["floorNumber"];
            this.hospitalUnitId = data["hospitalUnitId"];
            this.wardGenderName = data["wardGenderName"];
            this.wardStatusName = data["wardStatusName"];
            this.wardGenderId = data["wardGenderId"];
            this.wardStatusId = data["wardStatusId"];
        }
    }

    static fromJS(data: any): WardModel {
        data = typeof data === 'object' ? data : {};
        let result = new WardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wardId"] = this.wardId;
        data["name"] = this.name;
        data["buildingId"] = this.buildingId;
        data["floorNumber"] = this.floorNumber;
        data["hospitalUnitId"] = this.hospitalUnitId;
        data["wardGenderName"] = this.wardGenderName;
        data["wardStatusName"] = this.wardStatusName;
        data["wardGenderId"] = this.wardGenderId;
        data["wardStatusId"] = this.wardStatusId;
        return data; 
    }
}

export interface IWardModel {
    wardId?: number | undefined;
    name?: string | undefined;
    buildingId?: number | undefined;
    floorNumber?: number | undefined;
    hospitalUnitId?: number | undefined;
    wardGenderName?: string | undefined;
    wardStatusName?: string | undefined;
    wardGenderId?: WardGender | undefined;
    wardStatusId?: WardStatus | undefined;
}

export enum WardGender {
    Unisex = 0, 
    Male = 1, 
    Female = 2, 
}

export enum WardStatus {
    NotAvailable = 0, 
    BedsAvailable = 1, 
    Full = 2, 
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}
